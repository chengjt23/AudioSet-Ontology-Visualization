<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AudioSet Ontology å¯è§†åŒ–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .tree-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 30px;
            backdrop-filter: blur(10px);
        }

        .tree-node {
            margin: 5px 0;
            position: relative;
        }

        .node-content {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 4px solid #007bff;
            position: relative;
            overflow: hidden;
        }

        .node-content:hover {
            background: linear-gradient(45deg, #e3f2fd, #bbdefb);
            transform: translateX(10px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.3);
        }

        .node-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }

        .node-content:hover::before {
            left: 100%;
        }

        .toggle-icon {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #007bff;
            color: white;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .toggle-icon.expanded {
            transform: rotate(90deg);
            background: #28a745;
        }

        .toggle-icon.leaf {
            background: #6c757d;
            opacity: 0.5;
        }

        .node-name {
            font-weight: 600;
            color: #2c3e50;
            flex: 1;
            font-size: 14px;
        }

        .node-id {
            font-size: 11px;
            color: #6c757d;
            margin-left: 10px;
            font-family: monospace;
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .children {
            margin-left: 30px;
            border-left: 2px dashed #dee2e6;
            padding-left: 15px;
            max-height: 0;
            overflow: hidden;
        }

        .children.expanding {
            transition: max-height 0.4s ease;
            max-height: 50000px;
        }

        .children.expanded {
            max-height: 50000px;
        }

        .children.collapsing {
            transition: max-height 0.01s ease;
            max-height: 0;
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 18px;
            color: #666;
        }

        .stats {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            color: white;
            text-align: center;
            font-size: 14px; /* Adjust font size for more info */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tree-node-animated {
            animation: fadeIn 0.5s ease forwards;
        }

        @keyframes slideInFromTop {
            from { 
                opacity: 0; 
                transform: translateY(-30px);
                max-height: 0;
            }
            to { 
                opacity: 1; 
                transform: translateY(0);
                max-height: 50px;
            }
        }

        .btn-slide-in {
            animation: slideInFromTop 0.6s ease forwards;
        }

        .hidden-btn {
            display: none;
        }

        .undo-btn {
            padding: 10px 20px;
            background: #ffc107;
            color: #212529;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .undo-btn:hover {
            background: #e0a800;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255, 193, 7, 0.3);
        }

        .undo-btn:disabled {
            background: #6c757d;
            color: #adb5bd;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .delete-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .delete-btn:hover {
            background: #c82333;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸµ AudioSet Ontology å¯è§†åŒ–</h1>
        </div>

        <div class="stats" id="stats">
            <div>ç­‰å¾…åŠ è½½ontologyæ–‡ä»¶...</div>
        </div>

        <div class="file-upload" style="margin-bottom: 20px; text-align: center;">
            <input type="file" id="fileInput" accept=".json" style="display: none;">
            <input type="file" id="structureInput" accept=".json" style="display: none;">
            <button id="loadBtn" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">é€‰æ‹© ontology.json æ–‡ä»¶</button>
            <button id="loadStructureBtn" class="hidden-btn" style="padding: 10px 20px; background: #6f42c1; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">åŠ è½½åˆå¹¶åontologyæ–‡ä»¶</button>
            <button id="saveBtn" class="hidden-btn" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer;">ä¿å­˜åˆå¹¶åçš„æ ‘</button>
            <button id="undoBtn" class="undo-btn hidden-btn" disabled>æ’¤å›åˆ é™¤ (0)</button>
        </div>

        <div class="tree-container">
            <div id="treeContainer" class="loading">
                è¯·ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®é€‰æ‹© ontology.json æ–‡ä»¶å¼€å§‹ä½¿ç”¨
            </div>
        </div>
    </div>

<script>
    let originalOntologyData = [];
    let originalNodeMap = {};
    
    let nodeMap = {}; 
    let rootNodes = [];
    
    let expandedNodes = new Set();
    let deleteHistory = [];
    const MAX_HISTORY = 10;

    function loadFromFile(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                originalOntologyData = JSON.parse(e.target.result);
                expandedNodes.clear();
                deleteHistory = [];
                
                const saveBtn = document.getElementById('saveBtn');
                saveBtn.classList.add('hidden-btn');
                saveBtn.classList.remove('btn-slide-in');
                
                const loadStructureBtn = document.getElementById('loadStructureBtn');
                loadStructureBtn.classList.add('hidden-btn');
                loadStructureBtn.classList.remove('btn-slide-in');

                const undoBtn = document.getElementById('undoBtn');
                undoBtn.classList.add('hidden-btn');
                undoBtn.classList.remove('btn-slide-in');

                buildTree();

            } catch (error) {
                document.getElementById('treeContainer').innerHTML =
                    `<div style="text-align: center; color: #dc3545; padding: 20px;">
                        âŒ æ–‡ä»¶è§£æå¤±è´¥: ${error.message}
                     </div>`;
            }
        };
        reader.readAsText(file);
    }

    function buildTree() {
        if (!originalOntologyData || originalOntologyData.length === 0) {
            document.getElementById('treeContainer').innerHTML = 
                '<div style="text-align: center; color: #dc3545; padding: 20px;">âŒ æ²¡æœ‰æœ‰æ•ˆçš„æ•°æ®</div>';
            return;
        }

        nodeMap = {};
        rootNodes = [];
        originalNodeMap = {};

        originalOntologyData.forEach(node => {
            originalNodeMap[node.id] = node;
        });

        const childrenSet = new Set();
        originalOntologyData.forEach(node => {
            if (node.child_ids) {
                node.child_ids.forEach(childId => childrenSet.add(childId));
            }
        });

        const initialRootNodes = originalOntologyData.filter(node => !childrenSet.has(node.id));

        function createUniqueNode(originalNode, parentUniqueId) {
            const uniqueId = parentUniqueId ? `${originalNode.id}__${parentUniqueId}` : originalNode.id;
            if (nodeMap[uniqueId]) return nodeMap[uniqueId];

            const uniqueNode = {
                ...originalNode,
                uniqueId: uniqueId,
                parentUniqueId: parentUniqueId,
                children: []
            };
            nodeMap[uniqueId] = uniqueNode;

            if (originalNode.child_ids) {
                originalNode.child_ids.forEach(childId => {
                    const originalChildNode = originalNodeMap[childId];
                    if (originalChildNode) {
                        const childUniqueNode = createUniqueNode(originalChildNode, uniqueId);
                        if (childUniqueNode) {
                            uniqueNode.children.push(childUniqueNode);
                        }
                    }
                });
            }
            return uniqueNode;
        }
        
        initialRootNodes.forEach(root => {
            const rootInstance = createUniqueNode(root, null);
            rootNodes.push(rootInstance);
        });

        updateStats();
        renderTree();

        const saveBtn = document.getElementById('saveBtn');
        saveBtn.classList.remove('hidden-btn');
        saveBtn.classList.add('btn-slide-in');
        
        const loadStructureBtn = document.getElementById('loadStructureBtn');
        loadStructureBtn.classList.remove('hidden-btn');
        loadStructureBtn.classList.add('btn-slide-in');
        
        const undoBtn = document.getElementById('undoBtn');
        undoBtn.classList.remove('hidden-btn');
        undoBtn.classList.add('btn-slide-in');
        updateUndoButton();
    }

    function renderTree() {
        const container = document.getElementById('treeContainer');
        container.innerHTML = '';
        if (rootNodes.length === 0) {
            container.innerHTML = '<div style="text-align: center; color: #dc3545; padding: 20px;">âŒ æ²¡æœ‰æ‰¾åˆ°æ ¹èŠ‚ç‚¹</div>';
            return;
        }
        rootNodes.forEach(nodeInstance => {
            const nodeElement = createNodeElement(nodeInstance, 0, true);
            container.appendChild(nodeElement);
        });
    }

    function createNodeElement(node, level = 0, animated = false) {
        const nodeDiv = document.createElement('div');
        nodeDiv.className = 'tree-node';
        if (animated) {
            nodeDiv.classList.add('tree-node-animated');
            nodeDiv.style.animationDelay = `${level * 0.1}s`;
        }

        const contentDiv = document.createElement('div');
        contentDiv.className = 'node-content';
        
        const hasChildren = node.children && node.children.length > 0;
        
        const toggleIcon = document.createElement('div');
        toggleIcon.className = `toggle-icon ${!hasChildren ? 'leaf' : ''}`;
        toggleIcon.textContent = !hasChildren ? 'â—' : '+';

        const nameSpan = document.createElement('span');
        nameSpan.className = 'node-name';
        nameSpan.textContent = node.name || 'æœªå‘½å';

        const idSpan = document.createElement('span');
        idSpan.className = 'node-id';
        idSpan.textContent = node.id || '';

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.textContent = 'Ã—';
        deleteBtn.title = 'åˆ é™¤èŠ‚ç‚¹';
        deleteBtn.onclick = (e) => {
            e.stopPropagation();
            deleteNode(node.uniqueId);
        };

        contentDiv.appendChild(toggleIcon);
        contentDiv.appendChild(nameSpan);
        contentDiv.appendChild(idSpan);
        contentDiv.appendChild(deleteBtn);

        if (hasChildren) {
            const childrenDiv = document.createElement('div');
            childrenDiv.className = 'children';

            if (expandedNodes.has(node.uniqueId)) {
                node.children.forEach(childNode => {
                    const childElement = createNodeElement(childNode, level + 1, false);
                    childrenDiv.appendChild(childElement);
                });
                childrenDiv.classList.add('expanded');
                toggleIcon.classList.add('expanded');
                toggleIcon.textContent = 'âˆ’';
            }

            contentDiv.addEventListener('click', () => {
                const isExpanded = childrenDiv.classList.contains('expanded');
                
                if (!isExpanded) {
                    if (childrenDiv.children.length === 0) {
                        node.children.forEach(childNode => {
                            const childElement = createNodeElement(childNode, level + 1, false);
                            childrenDiv.appendChild(childElement);
                        });
                    }
                    childrenDiv.classList.remove('collapsing');
                    childrenDiv.classList.add('expanding', 'expanded');
                    toggleIcon.classList.add('expanded');
                    toggleIcon.textContent = 'âˆ’';
                    expandedNodes.add(node.uniqueId);
                } else {
                    childrenDiv.classList.remove('expanded', 'expanding');
                    childrenDiv.classList.add('collapsing');
                    toggleIcon.classList.remove('expanded');
                    toggleIcon.textContent = '+';
                    expandedNodes.delete(node.uniqueId);
                    setTimeout(() => childrenDiv.classList.remove('collapsing'), 50);
                }
                updateStats();
            });

            nodeDiv.appendChild(contentDiv);
            nodeDiv.appendChild(childrenDiv);
        } else {
            nodeDiv.appendChild(contentDiv);
        }

        return nodeDiv;
    }

    function getVisibleNodes() {
        const visibleNodeIds = new Set();
        function traverse(nodes) {
            nodes.forEach(node => {
                visibleNodeIds.add(node.uniqueId);
                if (expandedNodes.has(node.uniqueId) && node.children) {
                    traverse(node.children);
                }
            });
        }
        traverse(rootNodes);
        return visibleNodeIds;
    }
    
    // Helper function to get all uniqueIds of nodes currently acting as leaves
    function getVisibleLeafNodeUniqueIds() {
        const allVisibleUniqueIds = getVisibleNodes();
        const leafUniqueIds = new Set();

        allVisibleUniqueIds.forEach(uniqueId => {
            const node = nodeMap[uniqueId];
            if (node) {
                // A leaf is a node that either has no children or is currently collapsed.
                const isExpanded = expandedNodes.has(uniqueId);
                const hasChildren = node.children && node.children.length > 0;
                
                if (!hasChildren || !isExpanded) {
                    leafUniqueIds.add(uniqueId);
                }
            }
        });
        return leafUniqueIds;
    }
    
    // --- NEW: Function to get the deduplicated count of visible leaf nodes ---
    function getDeduplicatedLeafNodeCount() {
        const leafInstances = getVisibleLeafNodeUniqueIds();
        const uniqueOriginalIds = new Set();
        leafInstances.forEach(uniqueId => {
            const node = nodeMap[uniqueId];
            if (node) {
                uniqueOriginalIds.add(node.id); // The Set handles deduplication
            }
        });
        return uniqueOriginalIds.size;
    }

    // --- MAJOR CHANGE: updateStats now includes the new metric ---
    function updateStats() {
        const visibleNodeIds = getVisibleNodes();
        const leafNodeCount = getVisibleLeafNodeUniqueIds().size;
        const deduplicatedLeafCount = getDeduplicatedLeafNodeCount(); // New calculation
        
        const stats = document.getElementById('stats');
        const totalOriginalNodes = originalOntologyData.length;
        const totalOriginalLeafNodes = originalOntologyData.filter(n => !n.child_ids || n.child_ids.length === 0).length;
        
        stats.innerHTML = `
            <strong>æ€»èŠ‚ç‚¹æ•°:</strong> ${totalOriginalNodes} | 
            <strong>æ€»å¶èŠ‚ç‚¹æ•°:</strong> ${totalOriginalLeafNodes} | 
            <strong>æ ¹èŠ‚ç‚¹æ•°:</strong> ${rootNodes.length} <br>
            <strong>å½“å‰å¯è§èŠ‚ç‚¹:</strong> ${visibleNodeIds.size} | 
            <strong>å½“å‰å¶èŠ‚ç‚¹:</strong> ${leafNodeCount} |
            <strong>å»é‡åçš„å¶èŠ‚ç‚¹æ•°:</strong> ${deduplicatedLeafCount}
        `;
    }

    function generateMergedOntology() {
        const visibleUniqueIds = getVisibleNodes();
        const mergedData = [];
        const processedOriginalIds = new Set();
        const finalNodeMap = {};

        visibleUniqueIds.forEach(uniqueId => {
            const uniqueNode = nodeMap[uniqueId];
            if (uniqueNode && !processedOriginalIds.has(uniqueNode.id)) {
                const newNode = {
                    id: uniqueNode.id,
                    name: uniqueNode.name,
                    description: uniqueNode.description || "",
                    citation_uri: uniqueNode.citation_uri || "",
                    positive_examples: uniqueNode.positive_examples || [],
                    restrictions: uniqueNode.restrictions || [],
                    child_ids: []
                };
                mergedData.push(newNode);
                finalNodeMap[uniqueNode.id] = newNode;
                processedOriginalIds.add(uniqueNode.id);
            }
        });

        visibleUniqueIds.forEach(uniqueId => {
            const uniqueNode = nodeMap[uniqueId];
            if (uniqueNode && uniqueNode.parentUniqueId) {
                const parentNode = nodeMap[uniqueNode.parentUniqueId];
                if (parentNode && visibleUniqueIds.has(parentNode.uniqueId)) {
                    const finalParent = finalNodeMap[parentNode.id];
                    if (finalParent && !finalParent.child_ids.includes(uniqueNode.id)) {
                        finalParent.child_ids.push(uniqueNode.id);
                    }
                }
            }
        });

        return mergedData;
    }

    function downloadFile(content, filename) {
        const blob = new Blob([content], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function saveTreeState() {
        const mergedOntology = generateMergedOntology();
        if (mergedOntology.length === 0) {
            alert('æ²¡æœ‰å¯è§çš„èŠ‚ç‚¹å¯ä»¥ä¿å­˜');
            return;
        }

        const content = JSON.stringify(mergedOntology, null, 2);
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const filename = `merged_ontology_${timestamp}.json`;
        
        const stats = document.getElementById('stats');
        updateStats(); // Ensure stats are fresh before capturing
        const updatedHtml = stats.innerHTML;
        
        stats.innerHTML = `
            <strong>æ­£åœ¨ä¿å­˜...</strong> å¯è§èŠ‚ç‚¹æ•°: ${getVisibleNodes().size} | 
            æ–‡ä»¶å: ${filename}
        `;
        
        setTimeout(() => {
            downloadFile(content, filename);
            stats.innerHTML = updatedHtml;
        }, 500);
    }

    function deleteNode(uniqueId) {
        const nodeToDelete = nodeMap[uniqueId];
        if (!nodeToDelete) return;

        if (!confirm(`ç¡®å®šè¦åˆ é™¤èŠ‚ç‚¹ "${nodeToDelete.name}" åŠå…¶æ‰€æœ‰å­èŠ‚ç‚¹å—ï¼Ÿ`)) return;

        const parentNode = nodeToDelete.parentUniqueId ? nodeMap[nodeToDelete.parentUniqueId] : null;
        let originalIndex = -1;
        if (parentNode) {
            originalIndex = parentNode.children.findIndex(child => child.uniqueId === uniqueId);
            parentNode.children.splice(originalIndex, 1);
        } else {
            originalIndex = rootNodes.findIndex(root => root.uniqueId === uniqueId);
            if(originalIndex > -1) rootNodes.splice(originalIndex, 1);
        }

        const nodesToPurge = new Map();
        function collectDescendants(node) {
            nodesToPurge.set(node.uniqueId, node);
            if (node.children) {
                node.children.forEach(collectDescendants);
            }
        }
        collectDescendants(nodeToDelete);

        deleteHistory.push({
            node: nodeToDelete,
            parentNode: parentNode,
            index: originalIndex,
            purgedNodes: nodesToPurge,
            timestamp: Date.now()
        });
        if (deleteHistory.length > MAX_HISTORY) deleteHistory.shift();

        nodesToPurge.forEach((node, id) => {
            delete nodeMap[id];
            expandedNodes.delete(id);
        });

        renderTree();
        updateStats();
        updateUndoButton();
    }

    function undoDelete() {
        if (deleteHistory.length === 0) return;
        const lastDelete = deleteHistory.pop();
        const { node, parentNode, index, purgedNodes } = lastDelete;

        purgedNodes.forEach((n, id) => {
            nodeMap[id] = n;
        });

        if (parentNode) {
            if (nodeMap[parentNode.uniqueId]) {
                 parentNode.children.splice(index, 0, node);
            } else {
                 rootNodes.push(node);
            }
        } else {
            rootNodes.splice(index, 0, node);
        }

        renderTree();
        updateStats();
        updateUndoButton();
    }
    
    function updateUndoButton() {
        const undoBtn = document.getElementById('undoBtn');
        if (deleteHistory.length > 0) {
            undoBtn.disabled = false;
            undoBtn.textContent = `æ’¤å›åˆ é™¤ (${deleteHistory.length})`;
        } else {
            undoBtn.disabled = true;
            undoBtn.textContent = 'æ’¤å›åˆ é™¤';
        }
    }
    
    document.getElementById('loadBtn').addEventListener('click', () => {
        document.getElementById('fileInput').click();
    });
    
    document.getElementById('fileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            document.getElementById('treeContainer').innerHTML = '<div class="loading">æ­£åœ¨åŠ è½½æ–‡ä»¶...</div>';
            loadFromFile(file);
        }
    });

    document.getElementById('loadStructureBtn').addEventListener('click', () => {
        document.getElementById('structureInput').click();
    });

    document.getElementById('structureInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            document.getElementById('treeContainer').innerHTML = '<div class="loading">æ­£åœ¨åŠ è½½ç»“æ„çŠ¶æ€...</div>';
            loadStructureFromFile(file);
        }
    });

    function loadStructureFromFile(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const structureData = JSON.parse(e.target.result);
                applyStructureState(structureData);
            } catch (error) {
                alert('ç»“æ„æ–‡ä»¶è§£æå¤±è´¥: ' + error.message);
            }
        };
        reader.readAsText(file);
    }
    
    function applyStructureState(structureData) {
        if (!Array.isArray(structureData) || structureData.length === 0) {
            alert('æ— æ•ˆçš„ç»“æ„æ–‡ä»¶');
            return;
        }
        expandedNodes.clear();

        const parentIdsInStructure = new Set();
        structureData.forEach(node => {
            if (node.child_ids && node.child_ids.length > 0) {
                parentIdsInStructure.add(node.id);
            }
        });

        Object.values(nodeMap).forEach(uniqueNode => {
            if (parentIdsInStructure.has(uniqueNode.id)) {
                expandedNodes.add(uniqueNode.uniqueId);
            }
        });

        renderTree();
        const stats = document.getElementById('stats');
        updateStats();
        const updatedHtml = stats.innerHTML;
        stats.innerHTML = `<span style="color: white;">âœ“ ç»“æ„åŠ è½½æˆåŠŸ</span>`;
        setTimeout(() => { stats.innerHTML = updatedHtml; }, 1500);
    }

    document.getElementById('undoBtn').addEventListener('click', undoDelete);
    document.getElementById('saveBtn').addEventListener('click', saveTreeState);
</script>

</body>
</html>