<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AudioSet Ontology å¯è§†åŒ–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .tree-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 30px;
            backdrop-filter: blur(10px);
        }

        .tree-node {
            margin: 5px 0;
            position: relative;
        }

        .node-content {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 4px solid #007bff;
            position: relative;
            overflow: hidden;
        }

        .node-content:hover {
            background: linear-gradient(45deg, #e3f2fd, #bbdefb);
            transform: translateX(10px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.3);
        }

        .node-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }

        .node-content:hover::before {
            left: 100%;
        }

        .toggle-icon {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #007bff;
            color: white;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .toggle-icon.expanded {
            transform: rotate(90deg);
            background: #28a745;
        }

        .toggle-icon.leaf {
            background: #6c757d;
            opacity: 0.5;
        }

        .node-name {
            font-weight: 600;
            color: #2c3e50;
            flex: 1;
            font-size: 14px;
        }

        .node-id {
            font-size: 11px;
            color: #6c757d;
            margin-left: 10px;
            font-family: monospace;
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .children {
            margin-left: 30px;
            border-left: 2px dashed #dee2e6;
            padding-left: 15px;
            max-height: 0;
            overflow: hidden;
        }

        .children.expanding {
            transition: max-height 0.4s ease;
            max-height: 50000px;
        }

        .children.expanded {
            max-height: 50000px;
        }

        .children.collapsing {
            transition: max-height 0.01s ease;
            max-height: 0;
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 18px;
            color: #666;
        }

        .stats {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            color: white;
            text-align: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tree-node-animated {
            animation: fadeIn 0.5s ease forwards;
        }

        @keyframes slideInFromTop {
            from { 
                opacity: 0; 
                transform: translateY(-30px);
                max-height: 0;
            }
            to { 
                opacity: 1; 
                transform: translateY(0);
                max-height: 50px;
            }
        }

        .btn-slide-in {
            animation: slideInFromTop 0.6s ease forwards;
        }

        .hidden-btn {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸµ AudioSet Ontology å¯è§†åŒ–</h1>
        </div>

        <div class="stats" id="stats">
            <div>ç­‰å¾…åŠ è½½ontologyæ–‡ä»¶...</div>
        </div>

        <div class="file-upload" style="margin-bottom: 20px; text-align: center;">
            <input type="file" id="fileInput" accept=".json" style="display: none;">
            <input type="file" id="structureInput" accept=".json" style="display: none;">
            <button id="loadBtn" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">é€‰æ‹© ontology.json æ–‡ä»¶</button>
            <button id="loadStructureBtn" class="hidden-btn" style="padding: 10px 20px; background: #6f42c1; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">åŠ è½½åˆå¹¶åontologyæ–‡ä»¶</button>
            <button id="saveBtn" class="hidden-btn" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer;">ä¿å­˜åˆå¹¶åçš„æ ‘</button>
        </div>

        <div class="tree-container">
            <div id="treeContainer" class="loading">
                è¯·ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®é€‰æ‹© ontology.json æ–‡ä»¶å¼€å§‹ä½¿ç”¨
            </div>
        </div>
    </div>

    <script>
        let ontologyData = [];
        let nodeMap = {};
        let rootNodes = [];
        let expandedNodes = new Set(); // è·Ÿè¸ªå±•å¼€çš„èŠ‚ç‚¹

        function loadFromFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    ontologyData = JSON.parse(e.target.result);
                    expandedNodes.clear(); // é‡ç½®å±•å¼€çŠ¶æ€
                    
                    // éšè—æŒ‰é’®ç›´åˆ°æˆåŠŸæ„å»ºæ ‘
                    const saveBtn = document.getElementById('saveBtn');
                    saveBtn.classList.add('hidden-btn');
                    saveBtn.classList.remove('btn-slide-in');
                    saveBtn.disabled = true;
                    
                    const loadStructureBtn = document.getElementById('loadStructureBtn');
                    loadStructureBtn.classList.add('hidden-btn');
                    loadStructureBtn.classList.remove('btn-slide-in');
                    loadStructureBtn.disabled = true;
                    
                    buildTree();
                } catch (error) {
                    document.getElementById('treeContainer').innerHTML = 
                        '<div style="text-align: center; color: #dc3545; padding: 20px;">' +
                        'âŒ æ–‡ä»¶è§£æå¤±è´¥: ' + error.message +
                        '</div>';
                }
            };
            reader.readAsText(file);
        }

        function buildTree() {
            if (!ontologyData || ontologyData.length === 0) {
                document.getElementById('treeContainer').innerHTML = 
                    '<div style="text-align: center; color: #dc3545; padding: 20px;">âŒ æ²¡æœ‰æœ‰æ•ˆçš„æ•°æ®</div>';
                return;
            }

            ontologyData.forEach(node => {
                nodeMap[node.id] = node;
            });

            const childrenSet = new Set();
            ontologyData.forEach(node => {
                if (node.child_ids) {
                    node.child_ids.forEach(childId => {
                        childrenSet.add(childId);
                    });
                }
            });

            rootNodes = ontologyData.filter(node => !childrenSet.has(node.id));

            updateStats();

            renderTree();
            
            // åŒæ—¶æ˜¾ç¤ºå¹¶å¯ç”¨ä¸¤ä¸ªæŒ‰é’®ï¼Œæ·»åŠ åŠ¨ç”»æ•ˆæœ
            const saveBtn = document.getElementById('saveBtn');
            saveBtn.classList.remove('hidden-btn');
            saveBtn.classList.add('btn-slide-in');
            saveBtn.disabled = false;
            
            const loadStructureBtn = document.getElementById('loadStructureBtn');
            loadStructureBtn.classList.remove('hidden-btn');
            loadStructureBtn.classList.add('btn-slide-in');
            loadStructureBtn.disabled = false;
        }

        function loadStructureFromFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const structureData = JSON.parse(e.target.result);
                    applyStructureState(structureData);
                } catch (error) {
                    alert('ç»“æ„æ–‡ä»¶è§£æå¤±è´¥: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function applyStructureState(structureData) {
            if (!Array.isArray(structureData) || structureData.length === 0) {
                alert('æ— æ•ˆçš„ç»“æ„æ–‡ä»¶');
                return;
            }

            // æ¸…é™¤å½“å‰å±•å¼€çŠ¶æ€
            expandedNodes.clear();

            // åˆ†æç»“æ„æ–‡ä»¶ä¸­çš„èŠ‚ç‚¹å…³ç³»
            const structureNodeMap = {};
            const structureChildrenMap = {};

            structureData.forEach(node => {
                structureNodeMap[node.id] = node;
                if (node.child_ids && node.child_ids.length > 0) {
                    structureChildrenMap[node.id] = node.child_ids;
                }
            });

            // æ‰¾å‡ºéœ€è¦å±•å¼€çš„èŠ‚ç‚¹
            // å¦‚æœä¸€ä¸ªèŠ‚ç‚¹åœ¨ç»“æ„æ–‡ä»¶ä¸­æœ‰å­èŠ‚ç‚¹ï¼Œä¸”è¿™äº›å­èŠ‚ç‚¹ä¹Ÿåœ¨ç»“æ„æ–‡ä»¶ä¸­ï¼Œè¯´æ˜è¯¥èŠ‚ç‚¹åº”è¯¥å±•å¼€
            Object.keys(structureChildrenMap).forEach(nodeId => {
                const childIds = structureChildrenMap[nodeId];
                const hasVisibleChildren = childIds.some(childId => structureNodeMap[childId]);
                
                if (hasVisibleChildren && nodeMap[nodeId]) {
                    expandedNodes.add(nodeId);
                }
            });

            // é‡æ–°æ¸²æŸ“æ ‘ä»¥åº”ç”¨æ–°çš„å±•å¼€çŠ¶æ€
            renderTree();

            // æ˜¾ç¤ºåŠ è½½ç»“æœ
            const stats = document.getElementById('stats');
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            updateStats();
            const updatedHtml = stats.innerHTML;
            
            // æ˜¾ç¤ºç®€å•çš„æˆåŠŸæç¤º
            stats.innerHTML = `
                <span style="color: white;">âœ“ åŠ è½½æˆåŠŸ</span>
            `;
            
            setTimeout(() => {
                stats.innerHTML = updatedHtml;
            }, 1000);
        }

        function renderTree() {
            const container = document.getElementById('treeContainer');
            container.innerHTML = '';
            
            if (rootNodes.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #dc3545; padding: 20px;">âŒ æ²¡æœ‰æ‰¾åˆ°æ ¹èŠ‚ç‚¹</div>';
                return;
            }
            
            rootNodes.forEach(node => {
                const nodeElement = createNodeElement(node, 0, true); // åˆå§‹æ¸²æŸ“ä½¿ç”¨åŠ¨ç”»
                container.appendChild(nodeElement);
            });
        }

        function createNodeElement(node, level = 0, animated = false) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'tree-node';
            
            if (animated) {
                nodeDiv.classList.add('tree-node-animated');
                nodeDiv.style.animationDelay = `${level * 0.1}s`;
            }

            const contentDiv = document.createElement('div');
            contentDiv.className = 'node-content';
            
            const hasChildren = node.child_ids && node.child_ids.length > 0;
            
            const toggleIcon = document.createElement('div');
            toggleIcon.className = `toggle-icon ${!hasChildren ? 'leaf' : ''}`;
            toggleIcon.textContent = !hasChildren ? 'â—' : '+';

            const nameSpan = document.createElement('span');
            nameSpan.className = 'node-name';
            nameSpan.textContent = node.name || 'æœªå‘½å';

            const idSpan = document.createElement('span');
            idSpan.className = 'node-id';
            idSpan.textContent = node.id || '';

            contentDiv.appendChild(toggleIcon);
            contentDiv.appendChild(nameSpan);
            contentDiv.appendChild(idSpan);

            if (hasChildren) {
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'children';

                // å¦‚æœèŠ‚ç‚¹ä¹‹å‰æ˜¯å±•å¼€çš„ï¼Œä¿æŒå±•å¼€çŠ¶æ€
                if (expandedNodes.has(node.id)) {
                    node.child_ids.forEach(childId => {
                        const childNode = nodeMap[childId];
                        if (childNode) {
                            const childElement = createNodeElement(childNode, level + 1, false);
                            childrenDiv.appendChild(childElement);
                        }
                    });
                    childrenDiv.classList.add('expanded');
                    toggleIcon.classList.add('expanded');
                    toggleIcon.textContent = 'âˆ’';
                }

                contentDiv.addEventListener('click', () => {
                    const isExpanded = childrenDiv.classList.contains('expanded');
                    
                    if (!isExpanded) {
                        if (childrenDiv.children.length === 0) {
                            node.child_ids.forEach(childId => {
                                const childNode = nodeMap[childId];
                                if (childNode) {
                                    const childElement = createNodeElement(childNode, level + 1, false);
                                    childrenDiv.appendChild(childElement);
                                }
                            });
                        }
                        
                        // æ¸…é™¤æ‰€æœ‰åŠ¨ç”»ç±»
                        childrenDiv.classList.remove('collapsing');
                        // ä½¿ç”¨å±•å¼€åŠ¨ç”»
                        childrenDiv.classList.add('expanding');
                        childrenDiv.classList.add('expanded');
                        
                        toggleIcon.classList.add('expanded');
                        toggleIcon.textContent = 'âˆ’';
                        expandedNodes.add(node.id);
                    } else {
                        // æŠ˜å é€»è¾‘ - ç«‹å³æŠ˜å 
                        childrenDiv.classList.remove('expanded', 'expanding');
                        childrenDiv.classList.add('collapsing');
                        
                        toggleIcon.classList.remove('expanded');
                        toggleIcon.textContent = '+';
                        expandedNodes.delete(node.id);
                        
                        // çŸ­æš‚å»¶è¿Ÿåç§»é™¤collapsingç±»ï¼Œé¿å…å½±å“ä¸‹æ¬¡å±•å¼€
                        setTimeout(() => {
                            childrenDiv.classList.remove('collapsing');
                        }, 50);
                    }
                    
                    // åŠ¨æ€æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                    updateStats();
                });

                nodeDiv.appendChild(contentDiv);
                nodeDiv.appendChild(childrenDiv);
            } else {
                nodeDiv.appendChild(contentDiv);
            }

            return nodeDiv;
        }

        function getVisibleNodes() {
            const visibleNodes = new Set();
            const processedNodes = new Set();

            function addVisibleNode(nodeId) {
                if (processedNodes.has(nodeId)) return;
                processedNodes.add(nodeId);

                const node = nodeMap[nodeId];
                if (!node) return;

                visibleNodes.add(nodeId);

                // å¦‚æœèŠ‚ç‚¹æ˜¯å±•å¼€çš„ï¼Œæ·»åŠ å…¶å­èŠ‚ç‚¹
                if (expandedNodes.has(nodeId) && node.child_ids) {
                    node.child_ids.forEach(childId => {
                        addVisibleNode(childId);
                    });
                }
            }

            // ä»æ ¹èŠ‚ç‚¹å¼€å§‹
            rootNodes.forEach(rootNode => {
                addVisibleNode(rootNode.id);
            });

            return visibleNodes;
        }

        function getVisibleLeafNodes() {
            const visibleNodeIds = getVisibleNodes();
            let leafCount = 0;

            visibleNodeIds.forEach(nodeId => {
                const node = nodeMap[nodeId];
                if (node) {
                    // å¶èŠ‚ç‚¹å®šä¹‰ï¼šåœ¨å½“å‰å¯è§†çŠ¶æ€ä¸‹æ²¡æœ‰å¯è§çš„å­èŠ‚ç‚¹
                    const hasVisibleChildren = expandedNodes.has(nodeId) && 
                                               node.child_ids && 
                                               node.child_ids.some(childId => visibleNodeIds.has(childId));
                    
                    if (!hasVisibleChildren) {
                        leafCount++;
                    }
                }
            });

            return leafCount;
        }

        function updateStats() {
            const visibleNodeIds = getVisibleNodes();
            const leafNodeCount = getVisibleLeafNodes();
            
            const stats = document.getElementById('stats');
            stats.innerHTML = `
                <strong>æ€»èŠ‚ç‚¹æ•°:</strong> ${ontologyData.length} | 
                <strong>æ€»å¶èŠ‚ç‚¹æ•°:</strong> ${ontologyData.filter(n => !n.child_ids || n.child_ids.length === 0).length} | 
                <strong>æ ¹èŠ‚ç‚¹æ•°:</strong> ${rootNodes.length} | 
                <strong>å½“å‰å¯è§èŠ‚ç‚¹:</strong> ${visibleNodeIds.size} | 
                <strong>å½“å‰å¶èŠ‚ç‚¹:</strong> ${leafNodeCount}
            `;
        }

        function generateMergedOntology() {
            const visibleNodeIds = getVisibleNodes();
            const mergedData = [];

            visibleNodeIds.forEach(nodeId => {
                const originalNode = nodeMap[nodeId];
                if (originalNode) {
                    // åˆ›å»ºèŠ‚ç‚¹å‰¯æœ¬
                    const newNode = {
                        id: originalNode.id,
                        name: originalNode.name,
                        description: originalNode.description || "",
                        citation_uri: originalNode.citation_uri || "",
                        positive_examples: originalNode.positive_examples || [],
                        restrictions: originalNode.restrictions || []
                    };

                    // åªåŒ…å«å¯è§†çš„å­èŠ‚ç‚¹
                    if (originalNode.child_ids) {
                        newNode.child_ids = originalNode.child_ids.filter(childId => 
                            visibleNodeIds.has(childId)
                        );
                    } else {
                        newNode.child_ids = [];
                    }

                    mergedData.push(newNode);
                }
            });

            return mergedData;
        }

        function downloadFile(content, filename) {
            const blob = new Blob([content], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function saveTreeState() {
            const mergedOntology = generateMergedOntology();
            const visibleNodeIds = getVisibleNodes();
            
            if (mergedOntology.length === 0) {
                alert('æ²¡æœ‰å¯è§çš„èŠ‚ç‚¹å¯ä»¥ä¿å­˜');
                return;
            }

            const content = JSON.stringify(mergedOntology, null, 2);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `merged_ontology_${timestamp}.json`;
            
            // æ˜¾ç¤ºä¿å­˜ä¿¡æ¯
            const stats = document.getElementById('stats');
            const originalHtml = stats.innerHTML;
            
            // ç¡®ä¿ç»Ÿè®¡ä¿¡æ¯æ˜¯æœ€æ–°çš„
            updateStats();
            const updatedHtml = stats.innerHTML;
            
            // æ˜¾ç¤ºä¸´æ—¶ä¿å­˜ä¿¡æ¯
            stats.innerHTML = `
                <strong>æ­£åœ¨ä¿å­˜...</strong> å¯è§èŠ‚ç‚¹æ•°: ${visibleNodeIds.size} | 
                æ–‡ä»¶å: ${filename}
            `;
            
            setTimeout(() => {
                downloadFile(content, filename);
                stats.innerHTML = updatedHtml;
            }, 500);
        }

        document.getElementById('loadBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
        
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('treeContainer').innerHTML = '<div class="loading">æ­£åœ¨åŠ è½½æ–‡ä»¶...</div>';
                loadFromFile(file);
            }
        });

        document.getElementById('loadStructureBtn').addEventListener('click', () => {
            document.getElementById('structureInput').click();
        });

        document.getElementById('structureInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('treeContainer').innerHTML = '<div class="loading">æ­£åœ¨åŠ è½½ç»“æ„çŠ¶æ€...</div>';
                loadStructureFromFile(file);
            }
        });

        document.getElementById('saveBtn').addEventListener('click', saveTreeState);
    </script>
</body>
</html> 